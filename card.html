<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ø³ØªÙˆØ¯ÙŠÙˆ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª Ø§Ù„Ø§Ø­ØªØ±Ø§ÙÙŠ V4</title>
    <script async src="https://docs.opencv.org/4.5.4/opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>
    <style>
        :root {
            --primary: #2563eb;
            --secondary: #1e40af;
            --bg: #f1f5f9;
            --text: #0f172a;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }

        body { 
            background: var(--bg); 
            color: var(--text); 
            height: 100vh; 
            overflow: hidden; 
            display: flex; 
            flex-direction: column; 
        }

        .app-container {
            display: flex;
            flex-direction: column;
            height: 100%;
            background: white;
        }

        .header {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .main-layout {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .workspace {
            flex: 1;
            padding: 20px;
            background: #f8fafc;
            overflow-y: auto;
        }

        .upload-area {
            border: 2px dashed #cbd5e1;
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            background: white;
            margin-bottom: 20px;
            transition: 0.3s;
        }
        .upload-area:hover { border-color: var(--primary); background: #eff6ff; }

        /* --- Gallery & Drag Drop --- */
        .gallery {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
            gap: 15px;
            padding-bottom: 50px;
        }

        .card-item {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            transition: 0.2s;
            cursor: grab; /* Ù…Ø¤Ø´Ø± Ø§Ù„Ø³Ø­Ø¨ */
        }
        
        .card-item.dragging {
            opacity: 0.5;
            border: 2px dashed var(--primary);
            transform: scale(0.95);
        }

        .card-preview {
            height: 140px;
            background: #e2e8f0;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
        }
        .card-preview img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            pointer-events: none; /* Ù„Ù…Ù†Ø¹ Ø³Ø­Ø¨ Ø§Ù„ØµÙˆØ±Ø© Ù†ÙØ³Ù‡Ø§ Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† Ø§Ù„ÙƒØ§Ø±Øª */
        }

        /* Ù…Ø¤Ø´Ø± Ø§Ù„Ø­Ø§Ù„Ø© (ØªÙ„Ù‚Ø§Ø¦ÙŠ/ÙŠØ¯ÙˆÙŠ) */
        .crop-badge {
            position: absolute;
            top: 5px;
            right: 5px;
            font-size: 0.7rem;
            padding: 2px 6px;
            border-radius: 4px;
            color: white;
            font-weight: bold;
            z-index: 2;
        }
        .badge-auto { background: #16a34a; } /* Ø£Ø®Ø¶Ø± */
        .badge-manual { background: #ca8a04; } /* Ø£ØµÙØ± */

        .card-tools {
            display: flex;
            border-top: 1px solid #e2e8f0;
        }
        .tool-btn {
            flex: 1;
            background: white;
            border: none;
            border-right: 1px solid #f1f5f9;
            padding: 8px;
            cursor: pointer;
            transition: 0.2s;
        }
        .tool-btn:hover { background: #f8fafc; color: var(--primary); }
        .tool-btn.delete:hover { background: #fee2e2; color: #dc2626; }

        /* Sidebar */
        .sidebar {
            width: 300px;
            background: white;
            border-right: 1px solid #e2e8f0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            overflow-y: auto;
            flex-shrink: 0;
            z-index: 5;
            box-shadow: -2px 0 5px rgba(0,0,0,0.03);
        }

        .control-group label { display: block; font-size: 0.9rem; margin-bottom: 6px; font-weight: 600; color: #475569; }
        select, input { width: 100%; padding: 8px; border: 1px solid #cbd5e1; border-radius: 6px; }

        .btn-action {
            width: 100%; padding: 10px; border: none; border-radius: 6px;
            font-weight: bold; color: white; cursor: pointer; margin-bottom: 8px; font-size: 0.9rem;
        }
        .btn-print { background: #16a34a; }
        .btn-danger { background: #ef4444; }

        .footer {
            background: #1e293b; color: #94a3b8; padding: 8px; text-align: center; font-size: 0.8rem; flex-shrink: 0;
        }
        .footer a { color: #60a5fa; text-decoration: none; }

        /* Modal Editor */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 2000;
            display: none; justify-content: center; align-items: center;
        }
        .modal-overlay.active { display: flex; }

        .modal-content {
            background: #1e293b; width: 95%; max-width: 1000px; height: 90vh;
            border-radius: 12px; display: flex; flex-direction: column; overflow: hidden;
        }
        .editor-container {
            flex: 1; background: #333; display: flex; justify-content: center; align-items: center; cursor: crosshair;
        }
        canvas { max-width: 100%; max-height: 100%; box-shadow: 0 0 20px rgba(0,0,0,0.5); }

        /* Print CSS */
        #printableArea { position: absolute; top: -9999px; }
        @media print {
            body * { visibility: hidden; }
            #printableArea, #printableArea * { visibility: visible; }
            #printableArea { position: absolute; left: 0; top: 0; width: 100%; }
            @page { size: A4; margin: 0; }
            .print-page { width: 210mm; height: 297mm; page-break-after: always; padding: 10mm; background: white; }
            .print-grid { display: grid; gap: 5mm; align-content: start; }
            .print-item { border: 1px dashed #ccc; overflow: hidden; display: flex; justify-content: center; align-items: center; }
            .print-item img { width: 100%; height: 100%; object-fit: fill; }
        }
    </style>
</head>
<body>

<div class="app-container">
    <div class="header">
        <h1>ğŸ“¸ Ø³ØªÙˆØ¯ÙŠÙˆ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª <span style="font-size:0.8rem; opacity:0.8;">(Ø§Ù„Ù‚Øµ Ø§Ù„Ø°ÙƒÙŠ + Ø§Ù„ØªØ±ØªÙŠØ¨)</span></h1>
        <div id="statusBadge" style="background: rgba(255,255,255,0.2); padding: 5px 15px; border-radius: 20px; font-size: 0.8rem;">
            Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù†Ø¸Ø§Ù…... â³
        </div>
    </div>

    <div class="main-layout">
        <div class="workspace">
            <input type="file" id="fileInput" multiple accept="image/*" hidden>
            <div class="upload-area" onclick="document.getElementById('fileInput').click()">
                <h3>ğŸ“¤ Ø§Ø¶ØºØ· Ù„Ø±ÙØ¹ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª</h3>
                <p style="color:#64748b">Ø§Ù„Ù‚Øµ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ ÙŠØ¹Ù…Ù„ ÙÙˆØ±Ø§Ù‹ØŒ ÙˆÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ ÙˆØ§Ù„ØªØ±ØªÙŠØ¨ ÙŠØ¯ÙˆÙŠØ§Ù‹</p>
            </div>
            <div class="gallery" id="gallery"></div>
        </div>

        <div class="sidebar">
            <div class="control-group">
                <label>ØªØ®Ø·ÙŠØ· Ø§Ù„Ø·Ø¨Ø§Ø¹Ø©</label>
                <select id="cardsPerRow">
                    <option value="1">Ø¨Ø·Ø§Ù‚Ø© ÙˆØ§Ø­Ø¯Ø© (ÙƒØ¨ÙŠØ±Ø©)</option>
                    <option value="2" selected>Ø¨Ø·Ø§Ù‚ØªÙŠÙ† (Ù‚ÙŠØ§Ø³ÙŠ)</option>
                    <option value="3">3 Ø¨Ø·Ø§Ù‚Ø§Øª (ØµØºÙŠØ±Ø©)</option>
                </select>
            </div>
            <div class="control-group">
                <label>Ù†ÙˆØ¹ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø©</label>
                <select id="cardSize">
                    <option value="standard">Ø´Ø®ØµÙŠØ© (8.6x5.4 Ø³Ù…)</option>
                    <option value="large">ÙƒØ¨ÙŠØ±Ø© (9.0x6.0 Ø³Ù…)</option>
                </select>
            </div>
            <div class="control-group">
                <label>Ø§Ù„Ù…Ø³Ø§ÙØ© Ø§Ù„Ø¹Ù…ÙˆØ¯ÙŠØ© (Ù…Ù„Ù…)</label>
                <input type="number" id="vGap" value="5" min="0" max="50">
            </div>

            <div style="margin-top:auto">
                <button class="btn-action btn-print" onclick="printCards()">ğŸ–¨ï¸ Ø·Ø¨Ø§Ø¹Ø© Ø§Ù„ÙˆØ±Ù‚Ø©</button>
                <button class="btn-action btn-danger" onclick="clearAll()">ğŸ—‘ï¸ Ø­Ø°Ù Ø§Ù„ÙƒÙ„</button>
            </div>
        </div>
    </div>

    <div class="footer">
        Ø¨Ø±Ù…Ø¬Ø© ÙˆØªØ·ÙˆÙŠØ± <span style="color:#ef4444">â¤</span> <a href="https://www.facebook.com/en.mohamed.nasr" target="_blank">Ù…Ù‡Ù†Ø¯Ø³ Ù…Ø­Ù…Ø¯ Ø­Ù…Ø§Ø¯</a>
    </div>
</div>

<div class="modal-overlay" id="editorModal">
    <div class="modal-content">
        <div style="padding:15px; background:#0f172a; color:white; display:flex; justify-content:space-between;">
            <h3>âœ‚ï¸ ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø­Ø¯ÙˆØ¯</h3>
            <button onclick="closeEditor()" style="background:none; border:none; color:white; font-size:1.5rem; cursor:pointer;">&times;</button>
        </div>
        <div class="editor-container">
            <canvas id="editorCanvas"></canvas>
        </div>
        <div style="padding:15px; background:#0f172a; display:flex; justify-content:flex-end; gap:10px;">
            <button class="btn-action" style="width:auto; background:#475569;" onclick="closeEditor()">Ø¥Ù„ØºØ§Ø¡</button>
            <button class="btn-action btn-print" style="width:auto;" onclick="applyManualCrop()">âœ“ Ù‚Øµ ÙˆØ­ÙØ¸</button>
        </div>
    </div>
</div>

<div id="printableArea"></div>

<script>
    let cvReady = false;
    let cards = [];
    let currentEditId = null;
    
    // Drag & Drop Variables
    let dragSrcIndex = null;

    // Editor variables
    let canvas, ctx, originalImg = new Image(), points = [], isDragging = false, dragPoint = -1;

    function onOpenCvReady() {
        cvReady = true;
        document.getElementById('statusBadge').innerHTML = "âœ… Ø§Ù„Ù†Ø¸Ø§Ù… Ø¬Ø§Ù‡Ø²";
        document.getElementById('statusBadge').style.background = "#22c55e";
    }

    // --- Ø±ÙØ¹ Ø§Ù„ØµÙˆØ± ---
    document.getElementById('fileInput').addEventListener('change', async (e) => {
        if(!cvReady) return alert("Ø§Ù†ØªØ¸Ø± ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù†Ø¸Ø§Ù…...");
        for (const file of e.target.files) {
            await processFile(file);
        }
        e.target.value = '';
    });

    async function processFile(file) {
        const url = URL.createObjectURL(file);
        const img = new Image();
        img.src = url;
        await new Promise(r => img.onload = r);

        const id = Date.now() + Math.random();
        
        // --- 1. Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ù‚Øµ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ ÙÙˆØ±Ø§Ù‹ (Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ©) ---
        let processed = url;
        let detectedPoints = null;
        let method = 'manual'; // Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ Ø¥Ø°Ø§ ÙØ´Ù„

        try {
            const res = autoDetect(img);
            processed = res.url;
            detectedPoints = res.points;
            method = 'auto'; // Ù†Ø¬Ø­ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ
        } catch(e) {
            console.log("Auto detect failed, defaulting to original.");
            // Ù†Ø¨Ù‚ÙŠ processed = url (Ø§Ù„Ø£ØµÙ„ÙŠØ©)
            // Points = null
        }

        cards.push({
            id: id,
            original: url, 
            processed: processed,
            rotation: 0,
            points: detectedPoints,
            cropMethod: method // Ù„ØªØ­Ø¯ÙŠØ¯ Ù„ÙˆÙ† Ø§Ù„Ø¹Ù„Ø§Ù…Ø©
        });
        renderGallery();
    }

    // --- Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© OpenCV ---
    function autoDetect(imgElement) {
        let src = cv.imread(imgElement);
        let gray = new cv.Mat();
        let blur = new cv.Mat();
        let edges = new cv.Mat();

        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
        cv.GaussianBlur(gray, blur, new cv.Size(5, 5), 0);
        cv.Canny(blur, edges, 75, 200);

        let kernel = cv.Mat.ones(3, 3, cv.CV_8U);
        cv.dilate(edges, edges, kernel, new cv.Point(-1, -1), 1);

        let contours = new cv.MatVector();
        let hierarchy = new cv.Mat();
        cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

        let maxArea = 0;
        let bestApprox = null;

        for (let i = 0; i < contours.size(); ++i) {
            let cnt = contours.get(i);
            let area = cv.contourArea(cnt);
            if (area < 5000) continue;

            let peri = cv.arcLength(cnt, true);
            let approx = new cv.Mat();
            cv.approxPolyDP(cnt, approx, 0.02 * peri, true);

            if (approx.rows === 4 && area > maxArea) {
                maxArea = area;
                if(bestApprox) bestApprox.delete();
                bestApprox = approx.clone();
            }
            approx.delete();
        }

        if (!bestApprox) {
            src.delete(); gray.delete(); blur.delete(); edges.delete(); contours.delete(); hierarchy.delete();
            throw new Error("No card found");
        }

        let ptsData = [];
        for(let i=0; i<4; i++) ptsData.push({x: bestApprox.data32S[i*2], y: bestApprox.data32S[i*2+1]});

        src.delete(); gray.delete(); blur.delete(); edges.delete(); contours.delete(); hierarchy.delete(); bestApprox.delete();

        return warpImage(imgElement, ptsData);
    }

    function warpImage(imgSource, rawPoints) {
        rawPoints.sort((a,b) => a.y - b.y);
        const top = rawPoints.slice(0, 2).sort((a,b) => a.x - b.x);
        const bottom = rawPoints.slice(2, 4).sort((a,b) => a.x - b.x);
        const sorted = [top[0], top[1], bottom[1], bottom[0]];

        let src = cv.imread(imgSource);
        const width = 1000;
        const height = 630;

        let srcTri = cv.matFromArray(4, 1, cv.CV_32FC2, [sorted[0].x, sorted[0].y, sorted[1].x, sorted[1].y, sorted[2].x, sorted[2].y, sorted[3].x, sorted[3].y]);
        let dstTri = cv.matFromArray(4, 1, cv.CV_32FC2, [0, 0, width, 0, width, height, 0, height]);
        let M = cv.getPerspectiveTransform(srcTri, dstTri);
        let warped = new cv.Mat();
        cv.warpPerspective(src, warped, M, new cv.Size(width, height), cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar());

        let outCanvas = document.createElement('canvas');
        cv.imshow(outCanvas, warped);
        src.delete(); srcTri.delete(); dstTri.delete(); M.delete(); warped.delete();

        return { url: outCanvas.toDataURL('image/jpeg', 0.95), points: sorted };
    }

    // --- ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… (Gallery & Drag Drop) ---
    function renderGallery() {
        const gal = document.getElementById('gallery');
        gal.innerHTML = '';
        cards.forEach((card, index) => {
            const badgeClass = card.cropMethod === 'auto' ? 'badge-auto' : 'badge-manual';
            const badgeText = card.cropMethod === 'auto' ? 'âœ“ ØªÙ„Ù‚Ø§Ø¦ÙŠ' : 'âš ï¸ ÙŠØ¯ÙˆÙŠ';
            
            const div = document.createElement('div');
            div.className = 'card-item';
            div.draggable = true; // ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø³Ø­Ø¨
            div.dataset.index = index;
            
            div.innerHTML = `
                <div class="card-preview">
                    <span class="crop-badge ${badgeClass}">${badgeText}</span>
                    <img src="${card.processed}" style="transform: rotate(${card.rotation}deg)">
                </div>
                <div class="card-tools">
                    <button class="tool-btn" onclick="openEditor(${card.id})" title="ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ù‚Øµ">âœ‚ï¸</button>
                    <button class="tool-btn" onclick="rotate(${index})" title="ØªØ¯ÙˆÙŠØ±">ğŸ”„</button>
                    <button class="tool-btn delete" onclick="remove(${index})" title="Ø­Ø°Ù">âœ•</button>
                </div>
            `;
            
            addDragEvents(div);
            gal.appendChild(div);
        });
    }

    // --- Ù…Ù†Ø·Ù‚ Ø§Ù„Ø³Ø­Ø¨ ÙˆØ§Ù„Ø¥ÙÙ„Ø§Øª (Drag & Drop Logic) ---
    function addDragEvents(item) {
        item.addEventListener('dragstart', function(e) {
            dragSrcIndex = this.dataset.index;
            this.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        });

        item.addEventListener('dragover', function(e) {
            e.preventDefault(); // Ø¶Ø±ÙˆØ±ÙŠ Ù„Ù„Ø³Ù…Ø§Ø­ Ø¨Ø§Ù„Ø¥ÙÙ„Ø§Øª
            e.dataTransfer.dropEffect = 'move';
            return false;
        });

        item.addEventListener('dragenter', function(e) {
            this.style.border = '2px solid #2563eb';
        });

        item.addEventListener('dragleave', function(e) {
            this.style.border = '1px solid #e2e8f0';
        });

        item.addEventListener('drop', function(e) {
            e.stopPropagation();
            const dropTargetIndex = this.dataset.index;

            if (dragSrcIndex !== dropTargetIndex) {
                // ØªØ¨Ø¯ÙŠÙ„ Ø§Ù„Ø¹Ù†Ø§ØµØ± ÙÙŠ Ø§Ù„Ù…ØµÙÙˆÙØ©
                const temp = cards[dragSrcIndex];
                cards[dragSrcIndex] = cards[dropTargetIndex];
                cards[dropTargetIndex] = temp;
                
                // Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø±Ø³Ù…
                renderGallery();
            }
            return false;
        });

        item.addEventListener('dragend', function(e) {
            this.classList.remove('dragging');
            this.style.border = '1px solid #e2e8f0';
        });
    }

    function rotate(idx) { cards[idx].rotation = (cards[idx].rotation + 90) % 360; renderGallery(); }
    function remove(idx) { cards.splice(idx, 1); renderGallery(); }
    function clearAll() { if(confirm("Ø­Ø°Ù Ø§Ù„ÙƒÙ„ØŸ")) { cards = []; renderGallery(); } }

    // --- Ø§Ù„Ù…Ø­Ø±Ø± Ø§Ù„ÙŠØ¯ÙˆÙŠ (Manual Editor) ---
    function openEditor(id) {
        currentEditId = id;
        const card = cards.find(c => c.id === id);
        
        const modal = document.getElementById('editorModal');
        modal.classList.add('active'); // Ø¹Ø±Ø¶ Ø§Ù„Ù…ÙˆØ¯Ø§Ù„ Ø£ÙˆÙ„Ø§Ù‹

        canvas = document.getElementById('editorCanvas');
        ctx = canvas.getContext('2d');

        originalImg.src = card.original;
        originalImg.onload = () => {
            canvas.width = originalImg.width;
            canvas.height = originalImg.height;

            if (card.points) {
                points = JSON.parse(JSON.stringify(card.points));
            } else {
                // Ù†Ù‚Ø§Ø· Ø§ÙØªØ±Ø§Ø¶ÙŠØ© Ø¥Ø°Ø§ ÙØ´Ù„ Ø§Ù„Ù‚Øµ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ
                const w = canvas.width, h = canvas.height, p = w * 0.1;
                points = [{x: p, y: p}, {x: w-p, y: p}, {x: w-p, y: h-p}, {x: p, y: h-p}];
            }
            draw();
        };
        setupCanvasEvents();
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(originalImg, 0, 0);
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.fillRect(0,0, canvas.width, canvas.height);

        ctx.save();
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        ctx.lineTo(points[1].x, points[1].y);
        ctx.lineTo(points[2].x, points[2].y);
        ctx.lineTo(points[3].x, points[3].y);
        ctx.closePath();
        ctx.clip();
        ctx.drawImage(originalImg, 0, 0);
        ctx.restore();

        ctx.strokeStyle = '#00ff00';
        ctx.lineWidth = Math.max(2, canvas.width * 0.005);
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for(let i=1; i<4; i++) ctx.lineTo(points[i].x, points[i].y);
        ctx.closePath();
        ctx.stroke();

        points.forEach(p => {
            ctx.beginPath();
            ctx.arc(p.x, p.y, Math.max(10, canvas.width * 0.015), 0, Math.PI*2);
            ctx.fillStyle = 'red'; ctx.fill(); ctx.strokeStyle = 'white'; ctx.lineWidth = 3; ctx.stroke();
        });
    }

    function setupCanvasEvents() {
        const getPos = (e) => {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const cx = e.touches ? e.touches[0].clientX : e.clientX;
            const cy = e.touches ? e.touches[0].clientY : e.clientY;
            return { x: (cx - rect.left) * scaleX, y: (cy - rect.top) * scaleY };
        };

        const start = (e) => {
            const pos = getPos(e);
            const r = Math.max(50, canvas.width * 0.05);
            for(let i=0; i<4; i++) {
                const dx = pos.x - points[i].x, dy = pos.y - points[i].y;
                if(Math.sqrt(dx*dx + dy*dy) < r) {
                    isDragging = true; dragPoint = i; e.preventDefault(); return;
                }
            }
        };
        const move = (e) => {
            if(!isDragging) return;
            e.preventDefault();
            points[dragPoint] = getPos(e);
            draw();
        };
        const end = () => { isDragging = false; };

        canvas.onmousedown = start; canvas.onmousemove = move; canvas.onmouseup = end;
        canvas.ontouchstart = start; canvas.ontouchmove = move; canvas.ontouchend = end;
    }

    function applyManualCrop() {
        const res = warpImage(originalImg, JSON.parse(JSON.stringify(points)));
        const idx = cards.findIndex(c => c.id === currentEditId);
        if(idx !== -1) {
            cards[idx].processed = res.url;
            cards[idx].points = res.points;
            cards[idx].cropMethod = 'manual'; // ØªÙ… Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ ÙŠØ¯ÙˆÙŠØ§Ù‹
            renderGallery();
        }
        closeEditor();
    }

    function closeEditor() { document.getElementById('editorModal').classList.remove('active'); }

    // --- Ø§Ù„Ø·Ø¨Ø§Ø¹Ø© ---
    function printCards() {
        if(!cards.length) return alert("Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨Ø·Ø§Ù‚Ø§Øª");
        const area = document.getElementById('printableArea');
        const perRow = document.getElementById('cardsPerRow').value;
        const size = document.getElementById('cardSize').value;
        const gap = document.getElementById('vGap').value;
        const w = size === 'standard' ? '86mm' : '90mm';
        const h = size === 'standard' ? '54mm' : '60mm';

        let html = `<div class="print-page"><div class="print-grid" style="grid-template-columns: repeat(${perRow}, ${w}); row-gap: ${gap}mm;">`;
        cards.forEach(card => {
            html += `<div class="print-item" style="width:${w}; height:${h};"><img src="${card.processed}" style="transform: rotate(${card.rotation}deg)"></div>`;
        });
        html += `</div></div>`;
        area.innerHTML = html;
        window.print();
    }
</script>
</body>
</html>
