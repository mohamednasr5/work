<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ø³ØªÙˆØ¯ÙŠÙˆ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª Ø§Ù„Ø§Ø­ØªØ±Ø§ÙÙŠ</title>
    <script async src="https://docs.opencv.org/4.5.4/opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    
    <style>
        :root {
            --primary: #2563eb;
            --secondary: #1e40af;
            --accent: #f59e0b;
            --bg: #f1f5f9;
            --text: #0f172a;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }

        /* --- Ù…Ù†Ø¹ Ø§Ù„Ø§Ø³ÙƒØ±ÙˆÙ„ Ù„Ù„ØµÙØ­Ø© Ø¨Ø§Ù„ÙƒØ§Ù…Ù„ --- */
        body { 
            background: var(--bg); 
            color: var(--text); 
            height: 100vh; /* Ø§Ø±ØªÙØ§Ø¹ Ø§Ù„Ø´Ø§Ø´Ø© Ø¨Ø§Ù„ÙƒØ§Ù…Ù„ */
            overflow: hidden; /* Ø¥Ø®ÙØ§Ø¡ Ø´Ø±ÙŠØ· Ø§Ù„ØªÙ…Ø±ÙŠØ± Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ */
            display: flex; 
            flex-direction: column; 
        }

        /* --- Ø§Ù„Ù‡ÙŠÙƒÙ„ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ --- */
        .app-container {
            display: flex;
            flex-direction: column;
            height: 100%;
            max-width: 100%;
            margin: 0;
            background: white;
        }

        .header {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0; /* Ù…Ù†Ø¹ Ø§Ù„ØªØµØºÙŠØ± */
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            z-index: 10;
        }
        .header h1 { font-size: 1.4rem; display: flex; align-items: center; gap: 10px; }

        .main-layout {
            display: flex;
            flex: 1; /* ÙŠØ£Ø®Ø° Ø¨Ø§Ù‚ÙŠ Ø§Ù„Ù…Ø³Ø§Ø­Ø© */
            overflow: hidden; /* Ù…Ù‡Ù… Ø¬Ø¯Ø§Ù‹ */
        }

        /* --- Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ø¹Ù…Ù„ (Ø§Ù„ÙŠØ³Ø§Ø±) --- */
        .workspace {
            flex: 1;
            padding: 20px;
            background: #f8fafc;
            overflow-y: auto; /* Ø§Ù„Ø§Ø³ÙƒØ±ÙˆÙ„ Ù‡Ù†Ø§ ÙÙ‚Ø· */
            position: relative;
        }

        .upload-area {
            border: 2px dashed #cbd5e1;
            border-radius: 12px;
            padding: 30px;
            text-align: center;
            cursor: pointer;
            background: white;
            margin-bottom: 20px;
            transition: 0.3s;
        }
        .upload-area:hover { border-color: var(--primary); background: #eff6ff; }

        .gallery {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
            gap: 15px;
            padding-bottom: 50px;
        }

        .card-item {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            transition: 0.2s;
        }
        .card-item:hover { transform: translateY(-3px); box-shadow: 0 5px 15px rgba(0,0,0,0.1); }

        .card-preview {
            height: 140px;
            background: #e2e8f0;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
        }
        .card-preview img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        .card-tools {
            display: flex;
            border-top: 1px solid #e2e8f0;
        }
        .tool-btn {
            flex: 1;
            background: white;
            border: none;
            border-right: 1px solid #f1f5f9;
            padding: 8px;
            cursor: pointer;
            font-size: 1rem;
            transition: 0.2s;
        }
        .tool-btn:hover { background: #f8fafc; color: var(--primary); }
        .tool-btn.delete:hover { background: #fee2e2; color: #dc2626; }

        /* --- Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¬Ø§Ù†Ø¨ÙŠØ© (Ø§Ù„ÙŠÙ…ÙŠÙ†) --- */
        .sidebar {
            width: 300px;
            background: white;
            border-right: 1px solid #e2e8f0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            overflow-y: auto;
            flex-shrink: 0;
            z-index: 5;
            box-shadow: -2px 0 5px rgba(0,0,0,0.03);
        }

        .control-group label { display: block; font-size: 0.9rem; margin-bottom: 6px; font-weight: 600; color: #475569; }
        select, input { width: 100%; padding: 8px; border: 1px solid #cbd5e1; border-radius: 6px; }

        .btn-action {
            width: 100%; padding: 10px; border: none; border-radius: 6px;
            font-weight: bold; color: white; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px;
            margin-bottom: 8px; font-size: 0.9rem;
        }
        .btn-print { background: var(--success, #16a34a); }
        .btn-save { background: var(--primary); }
        .btn-danger { background: #ef4444; }

        /* --- Ø§Ù„ÙÙˆØªØ± --- */
        .footer {
            background: #1e293b;
            color: #94a3b8;
            padding: 8px;
            text-align: center;
            font-size: 0.8rem;
            flex-shrink: 0;
        }
        .footer a { color: #60a5fa; text-decoration: none; }

        /* --- Ø¥ØµÙ„Ø§Ø­ Ø§Ù„Ù…ÙˆØ¯Ø§Ù„ (Editor) --- */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 2000;
            display: none; justify-content: center; align-items: center;
            opacity: 0; transition: opacity 0.3s;
        }
        .modal-overlay.active { opacity: 1; }

        .modal-content {
            background: #1e293b; /* Ø®Ù„ÙÙŠØ© Ø¯Ø§ÙƒÙ†Ø© Ù„Ù„Ù…Ø­Ø±Ø± */
            width: 95%; max-width: 1000px; height: 90vh;
            border-radius: 12px;
            display: flex; flex-direction: column;
            overflow: hidden;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
        }

        .modal-header {
            padding: 15px; background: #0f172a; color: white;
            display: flex; justify-content: space-between; align-items: center;
        }

        .editor-container {
            flex: 1;
            position: relative;
            background: #333;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: crosshair;
        }

        /* Ø§Ù„Ù€ Canvas ÙŠØ£Ø®Ø° Ø­Ø¬Ù… Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠØŒ ÙˆÙ†Ø³ØªØ®Ø¯Ù… CSS Ù„ØªØ­Ø¬ÙŠÙ…Ù‡ */
        canvas {
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            max-width: 100%;
            max-height: 100%;
        }

        .modal-footer {
            padding: 15px; background: #0f172a; display: flex; justify-content: flex-end; gap: 10px;
        }

        /* Print CSS */
        #printableArea { position: absolute; top: -9999px; left: -9999px; }
        @media print {
            body * { visibility: hidden; }
            #printableArea, #printableArea * { visibility: visible; }
            #printableArea { position: absolute; left: 0; top: 0; width: 100%; }
            @page { size: A4; margin: 0; }
            .print-page { width: 210mm; height: 297mm; page-break-after: always; padding: 10mm; background: white; }
            .print-grid { display: grid; gap: 5mm; align-content: start; }
            .print-item { border: 1px dashed #ccc; overflow: hidden; display: flex; justify-content: center; align-items: center; }
            .print-item img { width: 100%; height: 100%; object-fit: fill; }
        }
    </style>
</head>
<body>

<div class="app-container">
    <div class="header">
        <h1>ğŸ“¸ Ø³ØªÙˆØ¯ÙŠÙˆ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª <span style="font-size:0.8rem; opacity:0.8; margin-right:10px;">(V3.0)</span></h1>
        <div id="statusBadge" style="background: rgba(255,255,255,0.2); padding: 5px 15px; border-radius: 20px; font-size: 0.8rem;">
            Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù†Ø¸Ø§Ù…... â³
        </div>
    </div>

    <div class="main-layout">
        <div class="workspace">
            <input type="file" id="fileInput" multiple accept="image/*" hidden>
            <div class="upload-area" onclick="document.getElementById('fileInput').click()">
                <div style="font-size: 2rem; margin-bottom: 10px;">ğŸ“¤</div>
                <h3>Ø§Ø¶ØºØ· Ù„Ø±ÙØ¹ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª</h3>
                <p style="color:#64748b">ÙŠØ¯Ø¹Ù… Ø§Ù„Ø³Ø­Ø¨ ÙˆØ§Ù„Ø¥ÙÙ„Ø§Øª ÙˆØªØ­Ø¯ÙŠØ¯ ØµÙˆØ± Ù…ØªØ¹Ø¯Ø¯Ø©</p>
            </div>
            <div class="gallery" id="gallery"></div>
        </div>

        <div class="sidebar">
            <div class="control-group">
                <label>ØªØ®Ø·ÙŠØ· Ø§Ù„Ø·Ø¨Ø§Ø¹Ø©</label>
                <select id="cardsPerRow">
                    <option value="1">Ø¨Ø·Ø§Ù‚Ø© ÙˆØ§Ø­Ø¯Ø© (ÙƒØ¨ÙŠØ±Ø©)</option>
                    <option value="2" selected>Ø¨Ø·Ø§Ù‚ØªÙŠÙ† (Ù‚ÙŠØ§Ø³ÙŠ)</option>
                    <option value="3">3 Ø¨Ø·Ø§Ù‚Ø§Øª (ØµØºÙŠØ±Ø©)</option>
                </select>
            </div>
            <div class="control-group">
                <label>Ù†ÙˆØ¹ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø©</label>
                <select id="cardSize">
                    <option value="standard">Ø´Ø®ØµÙŠØ© (8.6x5.4 Ø³Ù…)</option>
                    <option value="large">ÙƒØ¨ÙŠØ±Ø© (9.0x6.0 Ø³Ù…)</option>
                </select>
            </div>
            <div class="control-group">
                <label>Ø§Ù„Ù…Ø³Ø§ÙØ© Ø§Ù„Ø¹Ù…ÙˆØ¯ÙŠØ© (Ù…Ù„Ù…)</label>
                <input type="number" id="vGap" value="5" min="0" max="50">
            </div>

            <div style="margin-top:auto">
                <button class="btn-action btn-print" onclick="printCards()">ğŸ–¨ï¸ Ø·Ø¨Ø§Ø¹Ø© Ø§Ù„ÙˆØ±Ù‚Ø©</button>
                <button class="btn-action btn-save" onclick="saveImage()">ğŸ–¼ï¸ Ø­ÙØ¸ ÙƒØµÙˆØ±Ø©</button>
                <button class="btn-action btn-danger" onclick="clearAll()">ğŸ—‘ï¸ Ø­Ø°Ù Ø§Ù„ÙƒÙ„</button>
            </div>
        </div>
    </div>

    <div class="footer">
        Ø¨Ø±Ù…Ø¬Ø© ÙˆØªØ·ÙˆÙŠØ± <span style="color:#ef4444">â¤</span> <a href="https://www.facebook.com/en.mohamed.nasr" target="_blank">Ù…. Ù…Ø­Ù…Ø¯ Ø­Ù…Ø§Ø¯</a>
    </div>
</div>

<div class="modal-overlay" id="editorModal">
    <div class="modal-content">
        <div class="modal-header">
            <h3>âœ‚ï¸ Ø§Ù„Ù‚Øµ Ø§Ù„ÙŠØ¯ÙˆÙŠ Ø§Ù„Ø¯Ù‚ÙŠÙ‚</h3>
            <button onclick="closeEditor()" style="background:none; border:none; color:white; font-size:1.5rem; cursor:pointer;">&times;</button>
        </div>
        <div class="editor-container">
            <canvas id="editorCanvas"></canvas>
        </div>
        <div class="modal-footer">
            <span style="margin-left:auto; color:#94a3b8; font-size:0.9rem;">Ø­Ø±Ùƒ Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ø­Ù…Ø±Ø§Ø¡ Ù„ØªØ­Ø¯ÙŠØ¯ Ø£Ø±ÙƒØ§Ù† Ø§Ù„Ø¨Ø·Ø§Ù‚Ø©</span>
            <button class="btn-action" style="width:auto; background:#475569;" onclick="closeEditor()">Ø¥Ù„ØºØ§Ø¡</button>
            <button class="btn-action btn-save" style="width:auto;" onclick="applyManualCrop()">âœ“ Ù‚Øµ ÙˆØ­ÙØ¸</button>
        </div>
    </div>
</div>

<div id="printableArea"></div>

<script>
    let cvReady = false;
    let cards = [];
    let currentEditId = null;
    
    // Editor variables
    let canvas, ctx;
    let originalImg = new Image();
    let points = []; // [TL, TR, BR, BL]
    let isDragging = false;
    let dragPoint = -1;
    let scaleRatio = 1; // Ù„Ù„ØªØ­ÙˆÙŠÙ„ Ø¨ÙŠÙ† Ø­Ø¬Ù… Ø§Ù„Ø´Ø§Ø´Ø© ÙˆØ­Ø¬Ù… Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ

    function onOpenCvReady() {
        cvReady = true;
        document.getElementById('statusBadge').innerHTML = "âœ… Ø§Ù„Ù†Ø¸Ø§Ù… Ø¬Ø§Ù‡Ø²";
        document.getElementById('statusBadge').style.background = "#22c55e";
    }

    // --- Ø±ÙØ¹ Ø§Ù„ØµÙˆØ± ---
    document.getElementById('fileInput').addEventListener('change', async (e) => {
        if(!cvReady) return alert("Ø§Ù†ØªØ¸Ø± Ù„Ø­Ø¸Ø© ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù†Ø¸Ø§Ù…...");
        for (const file of e.target.files) {
            await processFile(file);
        }
        e.target.value = '';
    });

    async function processFile(file) {
        const url = URL.createObjectURL(file);
        const img = new Image();
        img.src = url;
        await new Promise(r => img.onload = r);

        const id = Date.now() + Math.random();
        
        // Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠØ©
        let processed = url;
        let detectedPoints = null;

        try {
            const res = autoDetect(img);
            processed = res.url;
            detectedPoints = res.points;
        } catch(e) {
            console.log("Auto fail", e);
        }

        cards.push({
            id: id,
            original: url, // Ù†Ø­ØªÙØ¸ Ø¨Ø§Ù„Ø£ØµÙ„ Ù„Ù„ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„ÙŠØ¯ÙˆÙŠ
            processed: processed,
            rotation: 0,
            points: detectedPoints
        });
        renderGallery();
    }

    // --- Ø§Ù„Ù‚Øµ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ (OpenCV) ---
    function autoDetect(imgElement) {
        let src = cv.imread(imgElement);
        let dst = new cv.Mat();
        let gray = new cv.Mat();
        let blur = new cv.Mat();
        let edges = new cv.Mat();

        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
        cv.GaussianBlur(gray, blur, new cv.Size(5, 5), 0);
        cv.Canny(blur, edges, 75, 200);

        // ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø­ÙˆØ§Ù Ø§Ù„Ù…ØªØµÙ„Ø©
        let kernel = cv.Mat.ones(3, 3, cv.CV_8U);
        cv.dilate(edges, edges, kernel, new cv.Point(-1, -1), 1);

        let contours = new cv.MatVector();
        let hierarchy = new cv.Mat();
        cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

        let maxArea = 0;
        let bestApprox = null;

        for (let i = 0; i < contours.size(); ++i) {
            let cnt = contours.get(i);
            let area = cv.contourArea(cnt);
            if (area < 5000) continue;

            let peri = cv.arcLength(cnt, true);
            let approx = new cv.Mat();
            cv.approxPolyDP(cnt, approx, 0.02 * peri, true);

            if (approx.rows === 4 && area > maxArea) {
                maxArea = area;
                if(bestApprox) bestApprox.delete();
                bestApprox = approx.clone();
            }
            approx.delete();
        }

        if (!bestApprox) {
            src.delete(); dst.delete(); gray.delete(); blur.delete(); edges.delete(); contours.delete(); hierarchy.delete();
            throw new Error("No card");
        }

        // ØªØ­Ø¶ÙŠØ± Ø§Ù„Ù†Ù‚Ø§Ø·
        let ptsData = [];
        for(let i=0; i<4; i++) {
            ptsData.push({x: bestApprox.data32S[i*2], y: bestApprox.data32S[i*2+1]});
        }

        // ØªÙ†Ø¸ÙŠÙ
        src.delete(); dst.delete(); gray.delete(); blur.delete(); edges.delete(); contours.delete(); hierarchy.delete(); bestApprox.delete();

        return warpImage(imgElement, ptsData);
    }

    function warpImage(imgSource, rawPoints) {
        // ØªØ±ØªÙŠØ¨ Ø§Ù„Ù†Ù‚Ø§Ø·
        rawPoints.sort((a,b) => a.y - b.y);
        const top = rawPoints.slice(0, 2).sort((a,b) => a.x - b.x);
        const bottom = rawPoints.slice(2, 4).sort((a,b) => a.x - b.x);
        const sorted = [top[0], top[1], bottom[1], bottom[0]];

        let src = cv.imread(imgSource);
        
        // Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ© (Ø¬ÙˆØ¯Ø© Ø¹Ø§Ù„ÙŠØ©)
        const width = 1000;
        const height = 630;

        let srcTri = cv.matFromArray(4, 1, cv.CV_32FC2, [
            sorted[0].x, sorted[0].y, sorted[1].x, sorted[1].y,
            sorted[2].x, sorted[2].y, sorted[3].x, sorted[3].y
        ]);
        let dstTri = cv.matFromArray(4, 1, cv.CV_32FC2, [0, 0, width, 0, width, height, 0, height]);
        
        let M = cv.getPerspectiveTransform(srcTri, dstTri);
        let warped = new cv.Mat();
        cv.warpPerspective(src, warped, M, new cv.Size(width, height), cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar());

        let outCanvas = document.createElement('canvas');
        cv.imshow(outCanvas, warped);
        
        // Cleanup
        src.delete(); srcTri.delete(); dstTri.delete(); M.delete(); warped.delete();

        return {
            url: outCanvas.toDataURL('image/jpeg', 0.95),
            points: sorted
        };
    }

    // --- Ø§Ù„Ù…Ø­Ø±Ø± Ø§Ù„ÙŠØ¯ÙˆÙŠ (Ø§Ù„Ø¥ØµÙ„Ø§Ø­ Ø§Ù„Ø¬Ø°Ø±ÙŠ) ---
    function openEditor(id) {
        currentEditId = id;
        const card = cards.find(c => c.id === id);
        
        const modal = document.getElementById('editorModal');
        modal.style.display = 'flex';
        // Force reflow
        setTimeout(() => modal.classList.add('active'), 10);

        canvas = document.getElementById('editorCanvas');
        ctx = canvas.getContext('2d');

        originalImg.src = card.original;
        originalImg.onload = () => {
            // 1. ØªØ¹ÙŠÙŠÙ† Ø­Ø¬Ù… Ø§Ù„ÙƒØ§Ù†ÙØ§Ø³ Ù„ÙŠÙƒÙˆÙ† Ø¨Ù†ÙØ³ Ø¯Ù‚Ø© Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ø£ØµÙ„ÙŠØ©
            canvas.width = originalImg.width;
            canvas.height = originalImg.height;

            // 2. Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ø£ÙˆÙ„ÙŠØ©
            if (card.points) {
                points = JSON.parse(JSON.stringify(card.points));
            } else {
                const w = canvas.width;
                const h = canvas.height;
                const p = w * 0.1; // Ù‡Ø§Ù…Ø´ 10%
                points = [
                    {x: p, y: p}, {x: w-p, y: p}, 
                    {x: w-p, y: h-p}, {x: p, y: h-p}
                ];
            }

            draw();
        };

        // Ø£Ø­Ø¯Ø§Ø« Ø§Ù„Ù…Ø§ÙˆØ³/Ø§Ù„Ù„Ù…Ø³
        setupCanvasEvents();
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Ø±Ø³Ù… Ø§Ù„ØµÙˆØ±Ø©
        ctx.drawImage(originalImg, 0, 0);

        // Ø·Ø¨Ù‚Ø© ØªØ¹ØªÙŠÙ…
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.fillRect(0,0, canvas.width, canvas.height);

        // ØªÙØ±ÙŠØº Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ù‚Øµ (Clip)
        ctx.save();
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        ctx.lineTo(points[1].x, points[1].y);
        ctx.lineTo(points[2].x, points[2].y);
        ctx.lineTo(points[3].x, points[3].y);
        ctx.closePath();
        ctx.clip();
        ctx.drawImage(originalImg, 0, 0); // Ø±Ø³Ù… Ø§Ù„Ø¬Ø²Ø¡ Ø§Ù„ÙˆØ§Ø¶Ø­ ÙÙ‚Ø·
        ctx.restore();

        // Ø±Ø³Ù… Ø§Ù„Ø®Ø·ÙˆØ·
        ctx.strokeStyle = '#00ff00';
        ctx.lineWidth = Math.max(2, canvas.width * 0.005); // Ø³Ù…Ùƒ Ù†Ø³Ø¨ÙŠ
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for(let i=1; i<4; i++) ctx.lineTo(points[i].x, points[i].y);
        ctx.closePath();
        ctx.stroke();

        // Ø±Ø³Ù… Ø§Ù„Ø¯ÙˆØ§Ø¦Ø±
        points.forEach(p => {
            ctx.beginPath();
            ctx.arc(p.x, p.y, Math.max(10, canvas.width * 0.015), 0, Math.PI*2);
            ctx.fillStyle = 'red';
            ctx.fill();
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3;
            ctx.stroke();
        });
    }

    function setupCanvasEvents() {
        const getPos = (e) => {
            // Ø§Ù„Ø³Ø± Ù‡Ù†Ø§: ØªØ­ÙˆÙŠÙ„ Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ø§Ù„Ø´Ø§Ø´Ø© Ø¥Ù„Ù‰ Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ø§Ù„ØµÙˆØ±Ø©
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            return {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY
            };
        };

        const start = (e) => {
            const pos = getPos(e);
            // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø£Ù‚Ø±Ø¨ Ù†Ù‚Ø·Ø© (Ù…Ø¹ Ù†ØµÙ Ù‚Ø·Ø± Ù„Ù…Ø³ ÙƒØ¨ÙŠØ±)
            const radius = Math.max(50, canvas.width * 0.05); 
            for(let i=0; i<4; i++) {
                const dx = pos.x - points[i].x;
                const dy = pos.y - points[i].y;
                if(Math.sqrt(dx*dx + dy*dy) < radius) {
                    isDragging = true;
                    dragPoint = i;
                    e.preventDefault();
                    return;
                }
            }
        };

        const move = (e) => {
            if(!isDragging) return;
            e.preventDefault();
            const pos = getPos(e);
            points[dragPoint] = pos;
            draw();
        };

        const end = () => { isDragging = false; };

        canvas.onmousedown = start;
        canvas.onmousemove = move;
        canvas.onmouseup = end;
        canvas.ontouchstart = start;
        canvas.ontouchmove = move;
        canvas.ontouchend = end;
    }

    function applyManualCrop() {
        const res = warpImage(originalImg, JSON.parse(JSON.stringify(points)));
        const idx = cards.findIndex(c => c.id === currentEditId);
        if(idx !== -1) {
            cards[idx].processed = res.url;
            cards[idx].points = res.points;
            renderGallery();
        }
        closeEditor();
    }

    function closeEditor() {
        const modal = document.getElementById('editorModal');
        modal.classList.remove('active');
        setTimeout(() => modal.style.display = 'none', 300);
    }

    // --- ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ---
    function renderGallery() {
        const gal = document.getElementById('gallery');
        gal.innerHTML = '';
        cards.forEach((card, index) => {
            const div = document.createElement('div');
            div.className = 'card-item';
            div.innerHTML = `
                <div class="card-preview">
                    <img src="${card.processed}" style="transform: rotate(${card.rotation}deg)">
                </div>
                <div class="card-tools">
                    <button class="tool-btn" onclick="openEditor(${card.id})" title="ØªØ¹Ø¯ÙŠÙ„ ÙŠØ¯ÙˆÙŠ">âœ‚ï¸</button>
                    <button class="tool-btn" onclick="rotate(${index})" title="ØªØ¯ÙˆÙŠØ±">ğŸ”„</button>
                    <button class="tool-btn delete" onclick="remove(${index})" title="Ø­Ø°Ù">âœ•</button>
                </div>
            `;
            gal.appendChild(div);
        });
    }

    function rotate(idx) { cards[idx].rotation = (cards[idx].rotation + 90) % 360; renderGallery(); }
    function remove(idx) { cards.splice(idx, 1); renderGallery(); }
    function clearAll() { if(confirm("Ø­Ø°Ù Ø§Ù„ÙƒÙ„ØŸ")) { cards = []; renderGallery(); } }

    // --- Ø§Ù„Ø·Ø¨Ø§Ø¹Ø© ---
    function printCards() {
        if(!cards.length) return alert("Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨Ø·Ø§Ù‚Ø§Øª");
        
        const area = document.getElementById('printableArea');
        const perRow = document.getElementById('cardsPerRow').value;
        const size = document.getElementById('cardSize').value;
        const gap = document.getElementById('vGap').value;
        
        const w = size === 'standard' ? '86mm' : '90mm';
        const h = size === 'standard' ? '54mm' : '60mm';

        let html = `<div class="print-page"><div class="print-grid" style="
            grid-template-columns: repeat(${perRow}, ${w});
            row-gap: ${gap}mm;">`;
        
        cards.forEach(card => {
            html += `<div class="print-item" style="width:${w}; height:${h};">
                <img src="${card.processed}" style="transform: rotate(${card.rotation}deg)">
            </div>`;
        });
        html += `</div></div>`;
        
        area.innerHTML = html;
        window.print();
    }

    function saveImage() {
        if(!cards.length) return;
        printCards(); // Ù„Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù€ HTML
        // Ù†Ø³ØªØ®Ø¯Ù… html2canvas Ø¹Ù„Ù‰ Ø§Ù„Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ù…Ø®ÙÙŠØ© (ØªØ·Ù„Ø¨ ØªØ¹Ø¯ÙŠÙ„ CSS Ø¨Ø³ÙŠØ· Ù„Ø¬Ø¹Ù„Ù‡Ø§ Ø¸Ø§Ù‡Ø±Ø© Ù…Ø¤Ù‚ØªØ§Ù‹ Ù„Ù„ÙƒØ§Ù†ÙØ§Ø³)
        // ... (Ù†ÙØ³ Ù…Ù†Ø·Ù‚ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø³Ø§Ø¨Ù‚)
    }

</script>
</body>
</html>
