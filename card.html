<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ø³ØªÙˆØ¯ÙŠÙˆ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª Ø§Ù„Ø§Ø­ØªØ±Ø§ÙÙŠ</title>
    <script async src="https://docs.opencv.org/4.5.4/opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    
    <style>
        :root {
            --primary: #2563eb;
            --secondary: #1e40af;
            --accent: #f59e0b;
            --bg: #f8fafc;
            --text: #0f172a;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }

        body { background: var(--bg); color: var(--text); min-height: 100vh; display: flex; flex-direction: column; }

        .container {
            flex: 1;
            max-width: 1400px;
            margin: 20px auto;
            background: white;
            border-radius: 16px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Header */
        .header {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            padding: 25px;
            text-align: center;
        }
        .header h1 { font-size: 1.8rem; margin-bottom: 5px; }

        /* Layout */
        .main-layout {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 0;
            flex: 1;
        }

        /* Upload & Gallery Area */
        .workspace {
            padding: 30px;
            background: #fff;
            overflow-y: auto;
        }

        .upload-box {
            border: 2px dashed #cbd5e1;
            border-radius: 12px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: 0.3s;
            background: #f1f5f9;
            margin-bottom: 30px;
        }
        .upload-box:hover { border-color: var(--primary); background: #eff6ff; }
        .upload-box h3 { color: var(--secondary); margin-bottom: 10px; }

        .gallery {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
            gap: 20px;
        }

        .card-item {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05);
            transition: 0.2s;
            position: relative;
        }
        .card-item:hover { transform: translateY(-4px); box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1); }

        .card-preview {
            height: 160px;
            background: #334155;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            padding: 10px;
        }
        .card-preview img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        .card-tools {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr;
            border-top: 1px solid #e2e8f0;
        }
        .tool-btn {
            background: #f8fafc;
            border: none;
            border-right: 1px solid #e2e8f0;
            padding: 10px;
            cursor: pointer;
            font-size: 1.1rem;
            transition: 0.2s;
        }
        .tool-btn:last-child { border-right: none; }
        .tool-btn:hover { background: #e2e8f0; }
        .btn-delete:hover { background: #fee2e2; color: #dc2626; }
        .btn-edit:hover { background: #dbeafe; color: var(--primary); }

        /* Sidebar */
        .sidebar {
            background: #f8fafc;
            border-right: 1px solid #e2e8f0;
            padding: 25px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .panel {
            background: white;
            padding: 20px;
            border-radius: 12px;
            border: 1px solid #e2e8f0;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }

        .panel h3 { font-size: 1rem; margin-bottom: 15px; color: var(--secondary); display: flex; align-items: center; gap: 8px; }

        .control-row { margin-bottom: 15px; }
        .control-row label { display: block; font-size: 0.9rem; margin-bottom: 8px; font-weight: 600; color: #475569; }
        select, input[type="range"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #cbd5e1;
            border-radius: 6px;
            outline: none;
        }

        .btn-action {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 10px;
            transition: 0.2s;
        }
        .btn-print { background: var(--success, #16a34a); }
        .btn-img { background: var(--primary); }
        .btn-pdf { background: #ea580c; }
        .btn-action:hover { filter: brightness(1.1); }

        /* Footer */
        .footer {
            background: #1e293b;
            color: #94a3b8;
            padding: 15px;
            text-align: center;
            font-size: 0.9rem;
        }
        .footer a { color: #60a5fa; text-decoration: none; }
        .heart-beat { color: #ef4444; display: inline-block; animation: beat 1s infinite; }
        @keyframes beat { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.2); } }

        /* --- Modal Editor (The Magic Part) --- */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 1000;
            display: none; justify-content: center; align-items: center;
        }
        .modal-content {
            background: white; padding: 20px; border-radius: 12px;
            width: 90%; max-width: 800px; height: 90vh;
            display: flex; flex-direction: column;
        }
        .editor-canvas-container {
            flex: 1; position: relative; background: #333;
            overflow: hidden; display: flex; justify-content: center; align-items: center;
            margin-bottom: 15px; border-radius: 8px;
        }
        .editor-canvas-container canvas { max-width: 100%; max-height: 100%; }
        
        .modal-actions { display: flex; justify-content: flex-end; gap: 10px; }
        
        /* Print Styles */
        #printableArea { position: absolute; top: -9999px; left: -9999px; }
        @media print {
            body * { visibility: hidden; }
            #printableArea, #printableArea * { visibility: visible; }
            #printableArea { position: absolute; left: 0; top: 0; width: 100%; }
            @page { size: A4; margin: 0; }
            .print-page { width: 210mm; height: 297mm; page-break-after: always; padding: 10mm; background: white; }
            .print-grid { display: grid; gap: 5mm; align-content: start; }
            .print-item { border: 1px dashed #ccc; overflow: hidden; display: flex; justify-content: center; align-items: center; }
            .print-item img { width: 100%; height: 100%; object-fit: fill; }
        }

    </style>
</head>
<body>

<div class="container">
    <div class="header">
        <h1>ğŸ“¸ Ø³ØªÙˆØ¯ÙŠÙˆ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª Ø§Ù„Ø§Ø­ØªØ±Ø§ÙÙŠ</h1>
        <p>Ù‚Øµ Ø°ÙƒÙŠ ÙˆØªØ¹Ø¯ÙŠÙ„ ÙŠØ¯ÙˆÙŠ Ø¯Ù‚ÙŠÙ‚ Ù„Ø¬Ù…ÙŠØ¹ Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª</p>
    </div>

    <div class="main-layout">
        <div class="workspace">
            <input type="file" id="fileInput" multiple accept="image/*" hidden>
            <div class="upload-box" onclick="document.getElementById('fileInput').click()">
                <h3>ğŸ“¤ Ø§Ø¶ØºØ· Ù„Ø±ÙØ¹ ØµÙˆØ± Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª</h3>
                <p>ÙŠØ¯Ø¹Ù… JPG, PNG - ÙŠÙØ¶Ù„ ØµÙˆØ± Ø¹Ø§Ù„ÙŠØ© Ø§Ù„Ø¬ÙˆØ¯Ø©</p>
                <div id="loadingStatus" style="color:var(--accent); margin-top:10px; font-weight:bold;">â³ Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ...</div>
            </div>

            <div class="gallery" id="gallery"></div>
        </div>

        <div class="sidebar">
            <div class="panel">
                <h3>ğŸ›  Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØµÙØ­Ø©</h3>
                
                <div class="control-row">
                    <label>Ø¹Ø¯Ø¯ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª ÙÙŠ Ø§Ù„ØµÙ</label>
                    <select id="cardsPerRow">
                        <option value="1">1 (ÙƒØ¨ÙŠØ±Ø©)</option>
                        <option value="2" selected>2 (Ù‚ÙŠØ§Ø³ÙŠ)</option>
                        <option value="3">3 (ØµØºÙŠØ±Ø©)</option>
                    </select>
                </div>

                <div class="control-row">
                    <label>Ø­Ø¬Ù… Ø§Ù„Ø¨Ø·Ø§Ù‚Ø©</label>
                    <select id="cardSize">
                        <option value="standard">Ù‚ÙŠØ§Ø³ÙŠ (8.6 Ã— 5.4 Ø³Ù…)</option>
                        <option value="large">ÙƒØ¨ÙŠØ± (9.0 Ã— 6.0 Ø³Ù…)</option>
                    </select>
                </div>

                <div class="control-row">
                    <label>Ø§Ù„Ù…Ø³Ø§ÙØ© Ø§Ù„Ø±Ø£Ø³ÙŠØ© (Ù…Ù„Ù…)</label>
                    <input type="range" id="verticalGap" min="0" max="30" value="5">
                </div>
            </div>

            <div class="panel">
                <h3>ğŸ–¨ Ø§Ù„ØªØµØ¯ÙŠØ±</h3>
                <button class="btn-action btn-print" onclick="printCards()">ğŸ–¨ Ø·Ø¨Ø§Ø¹Ø©</button>
                <button class="btn-action btn-img" onclick="saveImage()">ğŸ–¼ Ø­ÙØ¸ ØµÙˆØ±Ø©</button>
                <button class="btn-action btn-pdf" onclick="savePDF()">ğŸ“„ Ø­ÙØ¸ PDF</button>
                <button class="btn-action" style="background:#ef4444;" onclick="clearAll()">ğŸ—‘ Ø­Ø°Ù Ø§Ù„ÙƒÙ„</button>
            </div>
        </div>
    </div>

    <div class="footer">
        ØªÙ…Øª Ø§Ù„Ø¨Ø±Ù…Ø¬Ø© Ø¨ÙƒÙ„ Ø­Ø¨ <span class="heart-beat">â¤</span> Ø¨ÙˆØ§Ø³Ø·Ø© 
        <a href="https://www.facebook.com/en.mohamed.nasr" target="_blank">Ù…Ù‡Ù†Ø¯Ø³ Ù…Ø­Ù…Ø¯ Ø­Ù…Ø§Ø¯</a>
    </div>
</div>

<div class="modal-overlay" id="editorModal">
    <div class="modal-content">
        <h3 style="margin-bottom:10px;">âœ‚ ØªØ¹Ø¯ÙŠÙ„ Ø­Ø¯ÙˆØ¯ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø© ÙŠØ¯ÙˆÙŠØ§Ù‹</h3>
        <p style="font-size:0.9rem; color:#666; margin-bottom:10px;">Ø§Ø³Ø­Ø¨ Ø§Ù„Ø¯ÙˆØ§Ø¦Ø± Ø§Ù„Ø­Ù…Ø±Ø§Ø¡ Ø§Ù„Ø£Ø±Ø¨Ø¹Ø© Ù„ØªØ­Ø¯ÙŠØ¯ Ø£Ø±ÙƒØ§Ù† Ø§Ù„Ø¨Ø·Ø§Ù‚Ø© Ø¨Ø¯Ù‚Ø©ØŒ Ø«Ù… Ø§Ø¶ØºØ· "Ù‚Øµ ÙˆØ­ÙØ¸".</p>
        
        <div class="editor-canvas-container">
            <canvas id="editorCanvas"></canvas>
        </div>
        
        <div class="modal-actions">
            <button class="btn-action" style="width:auto; background:#64748b;" onclick="closeEditor()">Ø¥Ù„ØºØ§Ø¡</button>
            <button class="btn-action btn-print" style="width:auto;" onclick="applyManualCrop()">âœ“ Ù‚Øµ ÙˆØ­ÙØ¸</button>
        </div>
    </div>
</div>

<div id="printableArea"></div>

<script>
    let cvReady = false;
    let cards = [];
    let currentEditId = null;
    
    // Editor Variables
    let editCanvas, editCtx;
    let originalImage = new Image();
    let cropPoints = []; // [TL, TR, BR, BL]
    let isDragging = false;
    let dragPointIndex = -1;

    function onOpenCvReady() {
        cvReady = true;
        document.getElementById('loadingStatus').innerText = "âœ“ Ø§Ù„Ù†Ø¸Ø§Ù… Ø¬Ø§Ù‡Ø² - ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø±ÙØ¹ Ø§Ù„Ø¢Ù†";
        document.getElementById('loadingStatus').style.color = "green";
    }

    // --- File Handling ---
    document.getElementById('fileInput').addEventListener('change', async (e) => {
        if(!cvReady) return alert("Ø§Ù†ØªØ¸Ø± ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù†Ø¸Ø§Ù…...");
        for (const file of e.target.files) {
            await processFile(file);
        }
        e.target.value = '';
    });

    async function processFile(file) {
        const url = URL.createObjectURL(file);
        const img = new Image();
        img.src = url;
        await new Promise(r => img.onload = r);

        const id = Date.now() + Math.random();
        
        // 1. Try Auto Crop
        let processedUrl = url;
        let autoPoints = null;
        try {
            const result = autoDetectCard(img);
            processedUrl = result.url;
            autoPoints = result.points; // Save detection points for later editing if needed
        } catch (e) {
            console.log("Auto detection failed, using original.");
        }

        cards.push({
            id: id,
            originalUrl: url,
            processedUrl: processedUrl,
            rotation: 0,
            points: autoPoints // Store points for manual editor
        });
        
        renderGallery();
    }

    // --- OpenCV Auto Detection ---
    function autoDetectCard(img) {
        let src = cv.imread(img);
        let dst = new cv.Mat();
        let gray = new cv.Mat();
        let blur = new cv.Mat();
        let edges = new cv.Mat();

        // Preprocessing
        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
        cv.GaussianBlur(gray, blur, new cv.Size(5, 5), 0);
        
        // Use Canny + Dilate to close gaps (Good for rugs/patterns)
        cv.Canny(blur, edges, 75, 200);
        let kernel = cv.Mat.ones(3, 3, cv.CV_8U);
        cv.dilate(edges, edges, kernel, new cv.Point(-1, -1), 1);

        // Find Contours
        let contours = new cv.MatVector();
        let hierarchy = new cv.Mat();
        cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

        let maxArea = 0;
        let bestContour = null;
        let bestApprox = null;

        for (let i = 0; i < contours.size(); ++i) {
            let cnt = contours.get(i);
            let area = cv.contourArea(cnt);
            if (area < 5000) continue; // Ignore small noise

            let peri = cv.arcLength(cnt, true);
            let approx = new cv.Mat();
            cv.approxPolyDP(cnt, approx, 0.02 * peri, true);

            if (approx.rows === 4 && area > maxArea) {
                maxArea = area;
                bestContour = cnt;
                if(bestApprox) bestApprox.delete();
                bestApprox = approx.clone();
            }
            approx.delete();
        }

        if (!bestApprox) {
            // Cleanup and throw
            src.delete(); dst.delete(); gray.delete(); blur.delete(); edges.delete(); 
            contours.delete(); hierarchy.delete();
            throw new Error("No card found");
        }

        // Prepare points for warping
        let ptsData = [];
        for(let i=0; i<4; i++) {
            ptsData.push({x: bestApprox.data32S[i*2], y: bestApprox.data32S[i*2+1]});
        }
        
        // Clean memory
        src.delete(); dst.delete(); gray.delete(); blur.delete(); edges.delete(); 
        contours.delete(); hierarchy.delete(); bestApprox.delete();

        // Warp
        return performWarp(img, ptsData);
    }

    function performWarp(imgSource, pts) {
        let src = cv.imread(imgSource);
        
        // Sort Points: TL, TR, BR, BL
        pts.sort((a,b) => a.y - b.y);
        const top = pts.slice(0, 2).sort((a,b) => a.x - b.x);
        const bottom = pts.slice(2, 4).sort((a,b) => a.x - b.x);
        const sortedPts = [top[0], top[1], bottom[1], bottom[0]]; // Standard Order

        // Target Dimensions (High Res)
        const width = 1000;
        const height = 630; // Aspect Ratio for ID

        let srcTri = cv.matFromArray(4, 1, cv.CV_32FC2, [
            sortedPts[0].x, sortedPts[0].y, sortedPts[1].x, sortedPts[1].y,
            sortedPts[2].x, sortedPts[2].y, sortedPts[3].x, sortedPts[3].y
        ]);
        let dstTri = cv.matFromArray(4, 1, cv.CV_32FC2, [0, 0, width, 0, width, height, 0, height]);
        
        let M = cv.getPerspectiveTransform(srcTri, dstTri);
        let warped = new cv.Mat();
        
        cv.warpPerspective(src, warped, M, new cv.Size(width, height), cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar());
        
        // Create Canvas for output
        let canvas = document.createElement('canvas');
        cv.imshow(canvas, warped);
        
        // Cleanup
        src.delete(); srcTri.delete(); dstTri.delete(); M.delete(); warped.delete();

        return {
            url: canvas.toDataURL('image/jpeg', 0.95),
            points: sortedPts // Return the points used
        };
    }

    // --- Manual Editor Logic ---
    function openEditor(id) {
        currentEditId = id;
        const card = cards.find(c => c.id === id);
        
        // Setup Canvas
        editCanvas = document.getElementById('editorCanvas');
        editCtx = editCanvas.getContext('2d');
        
        originalImage.src = card.originalUrl;
        originalImage.onload = () => {
            // Resize canvas to fit screen while maintaining aspect ratio
            const container = document.querySelector('.editor-canvas-container');
            const scale = Math.min(container.clientWidth / originalImage.width, container.clientHeight / originalImage.height);
            
            editCanvas.width = originalImage.width;
            editCanvas.height = originalImage.height;
            
            // Set styles for visual scaling only
            editCanvas.style.width = (originalImage.width * scale) + 'px';
            editCanvas.style.height = (originalImage.height * scale) + 'px';

            // Initial points (Use auto-detected points if available, else corners)
            if (card.points && card.points.length === 4) {
                cropPoints = JSON.parse(JSON.stringify(card.points));
            } else {
                const w = editCanvas.width;
                const h = editCanvas.height;
                const p = 50; // padding
                cropPoints = [
                    {x: p, y: p}, {x: w-p, y: p}, 
                    {x: w-p, y: h-p}, {x: p, y: h-p}
                ];
            }
            
            drawEditor();
            document.getElementById('editorModal').style.display = 'flex';
        };

        // Event Listeners for Dragging
        editCanvas.addEventListener('mousedown', onMouseDown);
        editCanvas.addEventListener('mousemove', onMouseMove);
        editCanvas.addEventListener('mouseup', onMouseUp);
        // Touch support
        editCanvas.addEventListener('touchstart', onTouchStart, {passive: false});
        editCanvas.addEventListener('touchmove', onTouchMove, {passive: false});
        editCanvas.addEventListener('touchend', onMouseUp);
    }

    function drawEditor() {
        // Clear
        editCtx.clearRect(0, 0, editCanvas.width, editCanvas.height);
        // Draw Image
        editCtx.drawImage(originalImage, 0, 0);
        
        // Dark overlay
        editCtx.fillStyle = 'rgba(0,0,0,0.5)';
        editCtx.fillRect(0,0, editCanvas.width, editCanvas.height);

        // Draw Polygon (Clear area)
        editCtx.save();
        editCtx.beginPath();
        editCtx.moveTo(cropPoints[0].x, cropPoints[0].y);
        editCtx.lineTo(cropPoints[1].x, cropPoints[1].y);
        editCtx.lineTo(cropPoints[2].x, cropPoints[2].y);
        editCtx.lineTo(cropPoints[3].x, cropPoints[3].y);
        editCtx.closePath();
        editCtx.clip();
        editCtx.drawImage(originalImage, 0, 0);
        editCtx.restore();

        // Draw Lines
        editCtx.strokeStyle = '#ef4444';
        editCtx.lineWidth = 4;
        editCtx.beginPath();
        editCtx.moveTo(cropPoints[0].x, cropPoints[0].y);
        for(let i=1; i<4; i++) editCtx.lineTo(cropPoints[i].x, cropPoints[i].y);
        editCtx.closePath();
        editCtx.stroke();

        // Draw Circles
        cropPoints.forEach(p => {
            editCtx.fillStyle = '#ef4444';
            editCtx.beginPath();
            editCtx.arc(p.x, p.y, 15, 0, Math.PI*2);
            editCtx.fill();
            editCtx.strokeStyle = 'white';
            editCtx.lineWidth = 3;
            editCtx.stroke();
        });
    }

    function getMousePos(evt) {
        const rect = editCanvas.getBoundingClientRect();
        const scaleX = editCanvas.width / rect.width;
        const scaleY = editCanvas.height / rect.height;
        return {
            x: (evt.clientX - rect.left) * scaleX,
            y: (evt.clientY - rect.top) * scaleY
        };
    }
    
    // Mouse Events
    function onMouseDown(e) {
        const pos = getMousePos(e);
        checkDrag(pos);
    }
    function onMouseMove(e) {
        if(isDragging) {
            const pos = getMousePos(e);
            cropPoints[dragPointIndex] = pos;
            drawEditor();
        }
    }
    
    // Touch Events
    function onTouchStart(e) {
        e.preventDefault();
        const rect = editCanvas.getBoundingClientRect();
        const scaleX = editCanvas.width / rect.width;
        const scaleY = editCanvas.height / rect.height;
        const touch = e.touches[0];
        const pos = {
            x: (touch.clientX - rect.left) * scaleX,
            y: (touch.clientY - rect.top) * scaleY
        };
        checkDrag(pos);
    }
    function onTouchMove(e) {
        e.preventDefault();
        if(isDragging) {
            const rect = editCanvas.getBoundingClientRect();
            const scaleX = editCanvas.width / rect.width;
            const scaleY = editCanvas.height / rect.height;
            const touch = e.touches[0];
            cropPoints[dragPointIndex] = {
                x: (touch.clientX - rect.left) * scaleX,
                y: (touch.clientY - rect.top) * scaleY
            };
            drawEditor();
        }
    }

    function checkDrag(pos) {
        // Find closest point
        for(let i=0; i<4; i++) {
            let dx = pos.x - cropPoints[i].x;
            let dy = pos.y - cropPoints[i].y;
            if(Math.sqrt(dx*dx + dy*dy) < 50) { // Hit radius
                isDragging = true;
                dragPointIndex = i;
                return;
            }
        }
    }

    function onMouseUp() { isDragging = false; }

    function applyManualCrop() {
        const result = performWarp(originalImage, JSON.parse(JSON.stringify(cropPoints)));
        const idx = cards.findIndex(c => c.id === currentEditId);
        if(idx !== -1) {
            cards[idx].processedUrl = result.url;
            cards[idx].points = result.points;
            renderGallery();
        }
        closeEditor();
    }
    function closeEditor() { document.getElementById('editorModal').style.display = 'none'; }


    // --- Gallery & UI ---
    function renderGallery() {
        const gal = document.getElementById('gallery');
        gal.innerHTML = '';
        cards.forEach((card, index) => {
            const div = document.createElement('div');
            div.className = 'card-item';
            div.innerHTML = `
                <div class="card-preview">
                    <img src="${card.processedUrl}" style="transform: rotate(${card.rotation}deg)">
                </div>
                <div class="card-tools">
                    <button class="tool-btn btn-edit" onclick="openEditor(${card.id})" title="ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø­Ø¯ÙˆØ¯ ÙŠØ¯ÙˆÙŠØ§Ù‹">âœï¸</button>
                    <button class="tool-btn" onclick="rotate(${index})" title="ØªØ¯ÙˆÙŠØ±">ğŸ”„</button>
                    <button class="tool-btn" onclick="reset(${index})" title="Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ø£ØµÙ„">â†©ï¸</button>
                    <button class="tool-btn btn-delete" onclick="remove(${index})" title="Ø­Ø°Ù">âœ•</button>
                </div>
            `;
            gal.appendChild(div);
        });
    }

    function rotate(index) { cards[index].rotation = (cards[index].rotation + 90) % 360; renderGallery(); }
    function remove(index) { cards.splice(index, 1); renderGallery(); }
    function reset(index) { cards[index].processedUrl = cards[index].originalUrl; cards[index].points = null; renderGallery(); }
    function clearAll() { if(confirm("Ø­Ø°Ù Ø§Ù„ÙƒÙ„ØŸ")) { cards = []; renderGallery(); } }

    // --- Output & Printing ---
    function generateOutput() {
        const area = document.getElementById('printableArea');
        const perRow = document.getElementById('cardsPerRow').value;
        const sizeType = document.getElementById('cardSize').value;
        const vGap = document.getElementById('verticalGap').value;
        
        let width = sizeType === 'standard' ? '86mm' : '90mm';
        let height = sizeType === 'standard' ? '54mm' : '60mm';
        
        let html = `<div class="print-page"><div class="print-grid" style="
            grid-template-columns: repeat(${perRow}, ${width});
            row-gap: ${vGap}mm;">`;
        
        cards.forEach(card => {
            html += `<div class="print-item" style="width:${width}; height:${height};">
                <img src="${card.processedUrl}" style="transform: rotate(${card.rotation}deg)">
            </div>`;
        });
        
        html += `</div></div>`;
        area.innerHTML = html;
        return area;
    }

    function printCards() {
        if(!cards.length) return alert("Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨Ø·Ø§Ù‚Ø§Øª");
        generateOutput();
        window.print();
    }

    function saveImage() {
        if(!cards.length) return alert("Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨Ø·Ø§Ù‚Ø§Øª");
        generateOutput();
        const el = document.querySelector('.print-page');
        
        // Hack for html2canvas to render visible element
        const prevPos = document.getElementById('printableArea').style.position;
        document.getElementById('printableArea').style.position = 'static';
        
        html2canvas(el, {scale: 2}).then(canvas => {
            let a = document.createElement('a');
            a.download = 'cards.png';
            a.href = canvas.toDataURL();
            a.click();
            document.getElementById('printableArea').style.position = prevPos;
        });
    }

    function savePDF() {
        if(!cards.length) return alert("Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨Ø·Ø§Ù‚Ø§Øª");
        generateOutput();
        const el = document.querySelector('.print-page');
        const opt = {
            margin: 0, filename: 'cards.pdf',
            image: { type: 'jpeg', quality: 0.98 },
            html2canvas: { scale: 2 },
            jsPDF: { unit: 'mm', format: 'a4', orientation: 'portrait' }
        };
        html2pdf().set(opt).from(el).save();
    }

</script>
</body>
</html>
